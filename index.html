<html>
    <head>
        <meta charset="UTF-8"/>
        <link rel="stylesheet" href="node_modules/reveal.js/css/reveal.css">
        <link rel="stylesheet" href="node_modules/reveal.js/css/theme/white.css">
        <style>
            img {
                border: 0 !important;
                box-shadow: none !important;
                max-height: 500px !important;
            }
        </style>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section data-markdown>
                    <script type="text/template">
                        ## Приёмы и инструменты для работы с git
                        ---
                        <footer style="text-align: right;">
                            by: <img src="images/avatar.png"
                                     style="width: 1em; height: 1em; margin: 0; border: 0; box-shadow: none;" /><br/>
                            https://github.com/ForNeVeR<br/>
                            https://fornever.me/
                        </footer>

                        <aside class="notes">
                            Сегодня мы поговорим о системе контроля версий git:
                            о часто используемых приёмах работы с ней и об
                            основных инструментах, которые могут эту работу
                            облегчить.
                        </aside>
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Система контроля версий

                        ![VCS](images/vcs.svg)

                        <aside class="notes">
                            Система контроля версий — это средство управления
                            изменениями в проекте. Поговорим об основных
                            понятиях, которые часто упоминаются при обсуждении
                            таких систем.

                            Итак, вообще, "управление изменениями" — это когда
                            вы записываете каждое изменение каждого файла
                            проекта и храните историю этих изменений. На графе
                            обычно такие изменения обозначаются кружками,
                            называемых "коммитами". Каждый кружок — изменение
                            одного или нескольких файлов, и сопровождается
                            комментарием разработчика — что он сделал и зачем.
                            Эту историю всегда можно просмотреть и вернуться к
                            какой-то предыдущей версии.

                            Часто изменения могут группироваться в ветки, как на
                            этой картинке. Например, в основной ветке проекта
                            какой-то разработчик сделал изменение, а мне оно не
                            нужно — мешается, например. В этом случае я создаю
                            отдельную ветку, и вношу свои изменения в эту ветку.
                        </aside>
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Децентрализованная система контроля версий

                        ![Централизованная VSC](images/centralized-vcs.svg)
                        ![Децентрализованная VSC](images/decentralized-vcs.svg)

                        <aside class="notes">
                            Пожалуй, все уже знают, что git — это
                            децентрализованная система контроля версий в
                            противоположность SVN или TFS, которые считаются
                            централизованными. Но не всем понятна практическая
                            разница между этими способами работы с исходным
                            кодом.

                            Итак, системы контроля версий бывают
                            централизованные и децентрализованные. В
                            централизованных системах вся история изменений
                            исходного кода хранится строго и только в одном
                            месте — на главном сервере. Каждый разработчик
                            хранит у себя локально только последнюю версию
                            файлов проекта, с которой он и работает.

                            В децентрализованной системе контроля версий у
                            каждого разработчика на машине хранится полная копия
                            всего серверного репозитория со всеми ветками и всей
                            историей проекта. Такой вариант хранения обладает
                            некоторыми преимуществами: быстрее работает
                            переключение между ветками, можно делать коммиты без
                            наличия интернета. И, что немаловажно, можно
                            поменять историю — по крайней мере, в той её части,
                            которая ещё не была отправлена на сервер или другим
                            разработчикам.

                            Собственно, вот эта возможность по редактированию
                            истории и отличает git от большинства остальных VCS.
                            Для чего можно захотеть вдруг редактировать историю
                            — я расскажу дальше ☺
                        </aside>
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Структура репозитория

                        ![Структура репозитория](images/repo-structure.png)

                        <aside class="notes">
                            Теперь поговорим о том, что вообще бывает в
                            репозитории git. Понятно, что в принципе там лежат
                            файлы, которые составляют наш проект, но на данный
                            момент нам интересна метаинформация — коммиты,
                            ветки, связи между ними.

                            На картинке представлен граф коммитов open-source
                            репозитория. Что мы видим на графе? В первую
                            очередь, конечно, мы видим коммиты — атомарные
                            изменения, которые вносились по мере разработки
                            проекта. У каждого коммита есть также метаинформация
                            — сообщение, автор, дата и так далее.

                            Коммиты составляют граф, который в сложных
                            репозиториях бывает очень запутанным ☺

                            Из связанных коммитов состоит _ветка_. Ветка в git —
                            достаточно запутанное понятие, потому что под
                            _веткой_ зачастую понимают разные вещи: во-первых,
                            ветка — это именованная часть дерева. На картинке
                            видно ветку **master**. Ну а во-вторых, веткой
                            зачастую называют любую, даже неименованную цепочку
                            коммитов. Если понимать это и различать контексты,
                            то запутаться будет сложнее.

                            Именованная ветка в git — это на самом деле просто
                            указатель на один из коммитов. Когда разработчик
                            "добавляет коммиты в ветку" — на самом деле он
                            просто сдвигает указатель этой ветки на новые
                            коммиты.

                            Помимо веток, в git есть также _теги_. Теги это тоже
                            указатели на коммиты. Разница состоит в том, что
                            теги, как правило, не изменяются: будучи один раз
                            добавленными, они остаются и указывают на те же
                            коммиты (но можно их удалить). Тегами, как правило,
                            помечают релизные версии продукта, или просто
                            какие-то важные исторические вехи.

                            Помимо всего этого, есть так называемый stash —
                            отдельное локальное хранилище изменённых файлов.
                            Программист может убрать изменения в stash и достать
                            их оттуда в любой момент.
                        </aside>
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Статусы файлов

                        - **Untracked** (не отслеживаемый)
                        - **Staged** (отслеживаемый)
                        - **Unchanged** (не изменённый в репозитории)
                        - **Ignored** (игнорируемый, см. `.gitignore`,
                            `--assume-unchanged`)

                        <aside class="notes">
                            Мы обсудили структуру репозитория git, а теперь
                            поговорим про то, в каком статусе могут быть файлы
                            в репозитории.

                            Когда программист находится на каком-то коммите,
                            то у него в локальном каталоге находятся файлы,
                            соответствующие этому коммиту. По мере внесения
                            изменений и работы с файлами они могут приобретать
                            разные статусы.

                            С самого начала, когда мы добавляем новый файл
                            (например, создав его с помощью текстового
                            редактора) — он находится в состоянии **untracked**:
                            файл ещё не был добавлен в git, git про него ничего
                            не знает.

                            Чтобы подготовить файл к тому, что мы собираемся его
                            отправить в репозиторий, его следует пометить
                            статусом **staged**. Обычно для этого используют
                            консольную команду **add** или просто отмечают
                            галочкой в графическом интерфейсе. Файлы в этом
                            состоянии называются также "добавленными в индекс".

                            Если затем файл закоммитить, он перейдёт в статус
                            **unchanged**, и будет включён в какой-то коммит.

                            Кроме всего прочего, есть также известный многим
                            механизм игнорирования файлов. Обычно всякие
                            локальные конфиги, бинарники, временные файлы и пр.
                            мусор добавляют в `.gitignore`. *Следует отметить,
                            что `.gitignore` работает только для новых файлов!
                            Если поменять игнорированный файл — изменения из
                            него всё равно смогут попасть в репозиторий!* Для
                            того, чтобы игнорировать изменения в файле, который
                            уже есть в репозитории, нужно использовать ключ
                            `--assume-unchanged`.
                        </aside>
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Базовые операции

                        - `git add`
                        - `git commit`
                        - `git fetch`
                        - `git merge`
                        - `git pull` = `git fetch && git merge`
                        - `git push`

                        <aside class="notes">
                            Рассмотрим основные операции, которые часто
                            приходится выполнять при работе с git.

                            - `git add` добавляет файлы в индекс (т.е. готовит к
                              будущему коммиту).

                            - `git commit` делает коммит.

                            - `git fetch` скачивает изменения из удалённого
                              репозитория.

                            - `git merge` производит слияние нескольких веток и
                              делает коммит.

                            - `git pull` скачивает изменения из удалённого
                              репозитория и производит слияние с удалённой
                              веткой. Эта команда аналогична последовательному
                              вызову `git fetch` и `git merge`.

                            - `git push` отправляет изменения на удалённый
                              сервер.
                        </aside>
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## git reflog

                        ![git reflog](images/reflog.png)

                        <aside class="notes">
                            Ещё одной важнейшей и недооценённой командой
                            является `git reflog`. Эта команда позволяет
                            просматривать любые недавние изменения в репозитории
                            — в том числе те, которые были удалены, потеряны,
                            забыты.

                            Практически после любых деструктивных манипуляций с
                            деревом коммитов всё можно восстановить из reflog,
                            если вовремя спохватиться.
                        </aside>
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Операция git push

                        ![Иллюстрация проблемы git push](images/git-push.svg)

                        <aside class="notes">
                            Рассмотрим основную проблему, которая происходит при
                            `git push`. У нас есть серверный репозиторий, с
                            которым работает два разработчика. Каждый у себя
                            локально сделал по коммиту, и теперь они хотят их
                            запушить.

                            Первый успел запушить, а второй — не успел. И теперь
                            при `git push` у него будет дилемма – что делать?

                            У него есть самые разные варианты — как
                            деструктивные, так и не деструктивные.
                        </aside>
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Операция git push --force

                        ![git push --force](images/git-push-force.svg)

                        <aside class="notes">
                            Если второй разработчик — очень злой, или очень
                            много о себе воображает и очень быстро бегает, то он
                            может выполнить специальную команду — "force push".
                            Эта команда затирает серверные изменения его
                            локальными, уничтожая работу предыдущего
                            разработчика. Тот, в свою очередь, окажется в такой
                            же ситуации, и не сможет выполнить следующий `push`
                            на сервер.

                            Это не очень хорошо, но наличие такой возможности
                            позволяет исправить какие-то страшные оплошности —
                            например, если залили какую-то секретную информацию
                            или очень большой кусок данных, то можно их
                            попытаться быстро убрать, пока никто не заметил.

                            Такой подход будет создавать большие проблемы в
                            работе, если использовать его безответственно, и
                            потому его рекомендуется использовать только в самом
                            крайнем случае.
                        </aside>
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Операция merge

                        ![git merge](images/git-merge.svg)

                        <aside class="notes">
                            Недеструктивным вариантом действий для нашего
                            второго разработчика будет `git merge`. Это обычное
                            слияние, которое возьмёт коммит из двух веток,
                            объединит их и создаст новый коммит в дереве. Оно
                            никогда не теряет информации, т.к. итоговый коммит
                            всегда содержит ссылки на родительские коммиты.

                            Слияние этим способом является основной стратегией
                            для многих разработчиков, но на самом деле оно
                            является не единственно возможным. У него есть
                            недостатки: когда веток слишком много, в коммитах
                            слияния очень просто запутаться. Представьте, что
                            пара разработчиков работает над веткой, и они
                            проводят слияния после каждого коммита. Вместо
                            нормальной истории последовательных коммитов у них
                            получается змеиный клубок…
                        </aside>
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Merge hell

                        ![Merge hell](images/branches.png)
                        ![This is fine](images/this-is-fine.jpg)

                        <aside class="notes">
                            …а в итоге они приходят к чему-то вот такому.
                        </aside>
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Операция rebase

                        ![git rebase](images/git-rebase.svg)

                        <aside class="notes">
                            Для упрощения истории к нам на помощь спешит
                            операция `rebase`! Она может взять и переставить
                            локальный коммит поверх серверного (и не только
                            один коммит, а целую цепочку) — конечно, если при
                            этом возникнут конфликты в любом из коммитов, то их
                            придётся решать.

                            Преимущество у такой схемы — она позволяет избежать
                            лишних коммитов. Недостаток: теряется изначальный
                            вид коммитов. Если я их перебазировал поверх
                            какого-то кода, то они уже не выглядят так,
                            выглядели, когда я их делал. Может даже получиться
                            так, что код в промежуточных коммитах перестаёт
                            компилироваться, что, конечно, ужасно.

                            На практике лично я рекомендую использовать
                            `rebase`, если у вас накопилось немного изменений по
                            сравнению с центральным репозиторием — один-два
                            коммита. Перебазировать друг поверх друга какие-то
                            эпические ветки с сотнями коммитов, вероятно, не
                            стоит.
                        </aside>
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Fast-forward merge

                        ![git merge](images/merge-ff.svg)

                        <aside class="notes">
                            Частным случаем недеструктивного слияния является
                            так называемый fast-forward merge. Это такое
                            слияние, при котором разработчик просто
                            перетаскивает указатель своей ветки на более новый
                            коммит, не внося никаких изменений. Это слияние не
                            создаёт нового коммита в графе.
                        </aside>
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Операция squash

                        ![git squash](images/git-squash.svg)

                        <aside class="notes">
                            Иногда бывает, что во время разработки мы делаем
                            какие-то лишние, промежуточные коммиты. Если эти
                            коммиты ещё не были отправлены в рабочую ветку,
                            можно их объединить в один. Эта операция называется
                            `squash`, и делать её можно разными способами — и в
                            `git commit`, и в `git rebase` есть подходящие
                            опции.
                        </aside>
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Операция cherry-pick

                        ![git cherry-pick](images/git-cherry-pick.svg)

                        <aside class="notes">
                            Предположим, у меня есть пара веток, и мне хочется
                            перенести к себе один коммит из другой ветки и
                            разместить поверх текущей. Для этого есть элегантное
                            решение: `git cherry-pick`. Эта операция не
                            деструктивная, и часто пригождается для случаев,
                            когда, например, в соседней ветке поправили какой-то
                            баг, который тебе мешает, но ты не можешь пока что с
                            ней полноценно смержиться.
                        </aside>
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Интерактивный rebase

                        - `git rebase -i`
                        - ?????
                        - PROFIT

                        <aside class="notes">
                            Иногда бывают очень тяжёлые случаи, когда хочется
                            выполнить целую инструкцию: объединить некоторые
                            коммиты ветки с помощью `squash`, переставить
                            некоторые другие коммиты, удалить часть и
                            перебазировать другую. Для этого в консольном
                            инструменте `git rebase` есть "интерактивный" режим:
                            программист пишет *скрипт*, в котором указывает, что
                            делать с каждым из перебазируемых коммитов, а `git`
                            этот скрипт выполняет.

                            На моей практике, такая возможность нужна
                            исключительно редко. Но всегда лучше знать, что она
                            существует.
                        </aside>
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Операция stash

                        ![git stash](images/git-stash.svg)

                        <aside class="notes">
                            В нашей работе часто бывает, что ты пилишь какую-то
                            ветку, делаешь функциональность, и тут вдруг
                            подходит PM и просит срочно поправить что-нибудь не
                            связанное. Что в этом случае делать? Коммит?

                            Необязательно! Можно временно убрать изменения в
                            `stash`, и они там будут храниться, пока не
                            понадобятся. `git stash` — это также быстрый способ
                            очистить рабочий каталог от ненужных на данный
                            момент изменений, т.к. он их откладывает в отдельное
                            место и локально откатывает.

                            Таких stash'ей можно завести хоть по несколько,
                            привязанных к каждому коммиту. Они никогда не
                            отправляются на сервер, применить их и достать
                            изменения можно в любой момент.
                        </aside>
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Консольные инструменты

                        - git
                        - git bash
                        - git for Windows

                        <aside class="notes">
                            Поговорим про инструменты. git это в оригинале
                            консольная утилита, завязанная на инструментарий
                            Unix. Поэтому на Windows её поначалу портировали с
                            трудом, но сейчас начали более-менее управляться.

                            Самый популярный консольный инструмент — это "git
                            bash", который устанавливается в Windows вместе с
                            дистрибутивом `git`. При этом не все пользователи
                            осознают, что использовать команды `git` можно и
                            из обычной консоли — `cmd` или `powershell`.
                        </aside>
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## git gui

                        ![git gui](images/git-gui.png)

                        <aside class="notes">
                            Помимо прочего, в состав стандартной дистрибьюции
                            git входит также графический инструмент: `git gui`.
                            Выглядит он достаточно спартански.
                        </aside>
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## SourceTree

                        ![SourceTree](images/sourcetree.png)

                        <aside class="notes">
                            SourceTree — это бесплатный инструмент, к которому
                            многие привыкли, так что особо представлять я его
                            не стану. Из недостатков отмечу довольно тормозной
                            UI под Windows, и страшную локализацию, которую я
                            сходу не смог отключить. Из достоинств —
                            бесплатность и доступность под macOS (нет,
                            Linux-версии не завезли).
                        </aside>
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Лицензия SourceTree

                        ![Лицензия SourceTree](images/sourcetree-license.png)

                        <aside class="notes">
                            Однако, основным недостатком является лицензия,
                            которая требует обязательной атрибьюции во всех
                            разработанных продуктах. Если вы пользуетесь
                            SourceTree, то, будьте добры, пишите теперь везде
                            "Powered by Atlassian".
                        </aside>
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## SmartGit

                        ![SmartGit](images/smartgit.png)

                        <aside class="notes">
                            Другое средство работы с git — это SmartGit (лично
                            я пользуюсь именно им по коммерческой лицензии).

                            Бесплатная версия формально доступна только для
                            open-source разработки, написано на Java,
                            коммерческая лицензия стоит от $80.

                            Про данный инструмент я могу сказать только хорошее:
                            пожалуй, только оформление подкачало — нет тёмной
                            темы. А всё остальное работает как часы.
                        </aside>
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## GitKraken

                        ![GitKraken](images/gitkraken.png)

                        <aside class="notes">
                            Есть молодая, развивающаяся программа GitKraken,
                            написанная на JS с использованием Electron. Выглядит
                            и работает очень приятно; стоит отметить, что
                            операции с репозиторием на глаз выполняет быстрее,
                            чем SmartGit. Умеет делать отмену последних действий
                            с репозиториями. Не лишена небольших багов, но
                            саппорт обещает всё починить.

                            Бесплатная для open-source, персонального
                            использования и небольших стартапов. Для всех
                            остальных стоит $60 в год.
                        </aside>
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Git Extensions

                        ![Git Extensions](images/git-extensions.png)

                        <aside class="notes">
                            Существует также инструмент с открытым кодом Git
                            Extensions. Я был по отношению к нему настроен
                            скептически, однако перед докладом установил свежую
                            версию и, кажется, основные проблемы за прошедшее
                            время были исправлены. Работает достаточно быстро,
                            но выглядит не очень симпатично, и над UI явно ещё
                            можно поработать. Однако, это единственное известное
                            мне реально юзабельное средство, которое не требует
                            денег и не просит распространять его рекламу.
                        </aside>
                    </script>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        ## Это конец

                        <br/><br/><br/>
                        <small>Слайды доступны в репозитории https://github.com/ForNeVeR/git-basics</small>
                    </script>
                </section>
            </div>
        </div>
        <script src="node_modules/reveal.js/lib/js/head.min.js"></script>
        <script src="node_modules/reveal.js/js/reveal.js"></script>
        <script>
            var isPrintMode = window.location.search.match(/print-pdf/gi);
            var link = document.createElement('link');
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = isPrintMode
                ? 'node_modules/reveal.js/css/print/pdf.css'
                : 'node_modules/reveal.js/css/print/paper.css';
            document.getElementsByTagName('head')[0].appendChild(link);
            Reveal.initialize({
                dependencies: [
                    { src: 'node_modules/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'node_modules/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } }
                ],
                showNotes: isPrintMode
            });
        </script>
    </body>
</html>
